#!/usr/bin/env python3
# encoding: utf-8
import logging

from lxml import etree
from bs4 import BeautifulSoup
from confluence import Confluence
from utils import *
import IPy
import time
import os
from datetime import datetime
import re


span_remover = re.compile(r"<span( [^>]+)?>")
strong_remover = re.compile(r"<strong( [^>]+)?>")



logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger()

translations = {
   'Nimi': 'Name',
   'Kuvaus': 'Description',
}

reverse_translations = {v: k for k,v in translations.items()}

def _(name):
     if name in translations:
         return translations[name]
     if name in reverse_translations:
         return reverse_translations[name]
     return name

def parse_xml_table(table_string):
    # Confluence likes to output shitty html. Make it a little more pleasant to handle.
    table_string = table_string.replace('\x0a', ' ').replace('</span>', '').replace('</strong>', '')
    table_string = span_remover.sub('', table_string)
    table_string = strong_remover.sub('', table_string)
    table = etree.XML(str(table_string))
    rows = iter(table.find('tbody'))
    headers = [col.text for col in next(rows)]
    x = []
    for row in rows:
        values = []
        for col in row:
            if col.text is None:
                added = False
                for child in col:
                    try:
                        values.append(child.text.replace('\xa0', ' ').strip())
                        added = True
                        break
                    except ValueError:
                        pass
                if not added:
                    values.append(None)
            elif col.text == '\xa0':
                values.append(None)
            else:
                # Confluence likes to use nbsp
                values.append(col.text.replace('\xa0', ' ').strip())
        l = dict(zip(headers, values))
        x.append(l)
    return x


def fix_confluence_spaces(string):
    return string.replace('\x0a', ' ')


def find_longest_match(item, patterns):
    """
    Find longest match for item from patterns
    :param item:
    :param patterns:
    :return: longest pattern
    """

    match = None
    for pattern in patterns:
        if item.endswith(pattern):
            if not match or len(match) < len(pattern):
                match = pattern
    return match


class Record(object):
    def __init__(self, name, type, value, zone=None):
        self.name = name
        self.type = type
        self.value = value
        self.zone = zone

    @property
    def record(self):
        return "%(name)s IN %(type)s %(value)s" % {'name': self.name,
                                                   'type': self.type,
                                                   'value': self.value}

    def reverse(self):
        if self.type in ['A', 'AAAA']:
            return IPy.IP(self.value).reverseNames()[0]
        return None

    @property
    def fqdn(self):
        if not self.zone:
            return "%s." % self.name
        return "%s.%s." % (self.name, self.zone)

    def __str__(self):
        return self.record

    def __repr__(self):
        return self.record


class DNSUpdater(object):
    def __init__(self, base_url, username, password, page_id, verify_ssl=True):
        self.page_id = page_id
        self.c = Confluence(base_url, username, password, verify_ssl=verify_ssl)

    def update(self):

        t, zonelist = self.get_table()
        if not t:
            logger.error("Cannot get network list.")

        records = self.generate_forward_records(t, zones=zonelist)
        reverses = self.generate_reverse_records(zones=zonelist, records=records)

        for zone in records:
            self.generate_zonefile(zone, records[zone]['records'], records[zone]['zone'])

        for zone in reverses:
            self.generate_zonefile(zone, reverses[zone]['records'], reverses[zone]['zone'])

    def generate_zonefile(self, name, records, zone):
        zonefile = open(os.path.join(os.path.dirname(__file__), 'zones/%s' % name), 'w')
        out = lambda x: zonefile.write("%s\n" % x)
        out(";; %s" % zone)
        out(";; Autogenerated by %s at %s" % (__file__, datetime.now()))
        out("$TTL 60")
        out("@ IN SOA %s. %s. %d 3H 2H 2W 6H" % (zone['master'].rstrip('.'), zone['hostmaster'].rstrip('.'), time.time()))
        out("")
        for dns_server in zone['servers']:
            out("@ IN NS %s." % dns_server.rstrip('.'))
        out("")
        for record in records:
            out(record)
        out("")
        out("$INCLUDE /etc/bind/zones/%s.manual" % name.rstrip('.'))

    def get_table(self):
        page = self.c.get_page(self.page_id)

        if not page:
            logger.error("Cannot get page %s" % self.page_id)
            return

        soup = BeautifulSoup(page, 'lxml')

        networks = {}
        zones = {}

        network = None
        for table in soup.find_all('table'):
            lines = parse_xml_table(repr(table))
            if 'ZONE' in lines[0]:
                for line in lines:
                    if not 'ZONE' in line or line['ZONE'] is None:
                        continue
                    zone_name = line[_('ZONE')].split("#", 1)[-1].strip()
                    zones[zone_name] = {'hostmaster': line[_('hostmaster')].strip(),
                                        'master': line[_('master')].strip(),
                                        'servers': [x.strip() for x in fix_confluence_spaces(line[_('servers')]).split()]}
                continue
            if _('Name') not in lines[0] or lines[0][_('Name')] is None or not lines[0][_('Name')].startswith('# '):
                continue
            for line in lines:
                skip = False
                for item in ['Name', 'v4', 'v6', 'CNAME', 'Description']:
                    item = _(item)
                    if not item in line or line[item] is None:
                        skip = True
                if skip:
                    if _('Name') in line and line[_('Name')] and line[_('Name')].startswith("# "):
                        network = line[_('Name')].split("#",1)[1].strip()
                        if network not in networks:
                            networks[network] = []
                        continue
                networks[network].append(line)
        return networks, zones

    def generate_forward_records(self, table, zones):
        zones = {k: {'records': [], 'keys': [], 'zone': v} for k, v in zones.items() if not k.endswith('.arpa') and not k.endswith('.arpa.')}

        for network, items in table.items():
            zone = find_longest_match(network, zones.keys())
            if not zone:
                logger.error("Cannot find zone for network %s" % network)
                continue
            network_part = network[:len(network) - len(zone)].strip('.')
            for item in items:
                if network_part:
                    name = "%s.%s" % (item[_('Name')], network_part)
                else:
                    name = item[_('Name')]
                zones[zone]['keys'].append(name)
                if 'v4' in item and item['v4'] is not None:
                    if is_valid_ipv4_address(item['v4']):
                        zones[zone]['records'].append(Record(name, 'A', item['v4'], zone))
                        have_address = True
                if 'v6' in item and item['v6'] is not None:
                    if is_valid_ipv6_address(item['v6']):
                        zones[zone]['records'].append(Record(name, 'AAAA', item['v6'], zone))
                        have_address = True
                if 'CNAME' in item and item['CNAME'] is not None:
                    for cname in item['CNAME'].split():
                        cname = cname.strip().rstrip('.')
                        cname_network = find_longest_match(cname, zones.keys())
                        if not cname_network:
                            logger.info("Network not found for %s" % cname)
                            cname_network = zone
                            cname = '%s.%s' % (cname, cname_network)
                        cname_part = cname[:len(cname) - len(cname_network) - 1]
                        if cname_part in zones[cname_network]['keys']:
                            logger.error("Cannot add CNAME for %s, address have already other records!" % cname)
                            continue
                        zones[cname_network]['records'].append(Record(cname_part, 'CNAME', "%s.%s." % (name, zone), cname_network))
                        zones[cname_network]['keys'].append(cname_part)
        return zones

    def generate_reverse_records(self, zones, records):
        zones = {"%s." % k.rstrip('.'): {'records': [], 'keys': [], 'zone': v} for k,v in zones.items() if k.endswith('.arpa') or k.endswith('.arpa.')}
        for network in records:
            for record in records[network]['records']:
                if record.type not in ['A', 'AAAA']:
                    continue
                reverse = record.reverse()
                reverse_zone = find_longest_match(reverse, zones.keys())
                if not reverse_zone:
                    logger.error("Cannot find reverse zone for %s (%s)" % (reverse, record.fqdn))
                    continue
                key = reverse[:len(reverse) - len(reverse_zone) - 1]
                zones[reverse_zone]['records'].append(Record(key, 'PTR', record.fqdn, reverse_zone))
        return zones


if __name__ == '__main__':
    import config
    d = DNSUpdater(config.base_url, config.username, config.password, config.page_id, config.verify_ssl)
    d.update()
